{"ast":null,"code":"// import React, { useEffect, useRef, useState } from 'react'\n// import styles from \"../styles/videoComponent.module.css\";\n// import { io } from \"socket.io-client\";\n// import { Badge, IconButton, TextField } from '@mui/material';\n// import { Button } from '@mui/material';\n// import VideocamIcon from '@mui/icons-material/Videocam';\n// import VideocamOffIcon from '@mui/icons-material/VideocamOff'\n// import CallEndIcon from '@mui/icons-material/CallEnd'\n// import MicIcon from '@mui/icons-material/Mic'\n// import MicOffIcon from '@mui/icons-material/MicOff'\n// import ScreenShareIcon from '@mui/icons-material/ScreenShare';\n// import StopScreenShareIcon from '@mui/icons-material/StopScreenShare'\n// import ChatIcon from '@mui/icons-material/Chat'\n\n// const server_url = \"http://localhost:8000\";\n\n// var connections = {};\n\n// const peerConfigConnections = {\n//     \"iceServers\" : [\n//         { \"urls\" : \"stun:stun.l.google.com:19302\"}\n//     ]\n// }\n\n// export default function VideoMeetComponent() {\n\n//     var socketRef = useRef();\n\n//     let socketIdRef = useRef();\n\n//     let localVideoRef = useRef();\n\n//     let[videoAvailable, setVideoAvailable] = useState(true);\n\n//     let[audioAvailable, setAudioAvailable] = useState(true);\n\n//     let[video, setVideo] = useState([]);\n\n//     let [audio, setAudio] = useState();\n\n//     let[screen, setScreen] = useState();\n\n//     let[showModal, setModal] = useState(true);\n\n//     let[screenAvailable, setScreenAvailable] = useState();\n\n//     let[messages, setMessages] = useState([])\n\n//     let[message, setMessage] = useState(\"\");\n\n//     let[newMessages, setNewMessages] = useState(0);\n\n//     let [askForUsername, setAskForUsername] = useState(true);\n\n//     let [username, setUsername] = useState(\"\");\n\n//     const videoRef = useRef([])\n\n//     let [videos, setVideos] = useState([])\n\n//     useEffect(() => {\n//         // console.log(\"HELLO\")\n//         getPermissions();\n//     },[])\n\n//     let getDislayMedia = () => {\n//         if (screen) {\n//             if (navigator.mediaDevices.getDisplayMedia) {\n//                 navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })\n//                     .then(getDislayMediaSuccess)\n//                     .then((stream) => { })\n//                     .catch((e) => console.log(e))\n//             }\n//         }\n//     }\n\n//    let getUserMediaSuccess = (stream) => {\n//         try {\n//             window.localStream.getTracks().forEach(track => track.stop())\n//         } catch (e) { console.log(e) }\n\n//         window.localStream = stream\n//         localVideoRef.current.srcObject = stream\n\n//         for (let id in connections) {\n//             if (id === socketIdRef.current) continue\n\n//             connections[id].addStream(window.localStream)\n\n//             connections[id].createOffer().then((description) => {\n//                 console.log(description)\n//                 connections[id].setLocalDescription(description)\n//                     .then(() => {\n//                         socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\n//                     })\n//                     .catch(e => console.log(e))\n//             })\n//         }\n\n//         stream.getTracks().forEach(track => track.onended = () => {\n//             setVideo(false);\n//             setAudio(false);\n\n//             try {\n//                 let tracks = localVideoRef.current.srcObject.getTracks()\n//                 tracks.forEach(track => track.stop())\n//             } catch (e) { console.log(e) }\n\n//             let blackSilence = (...args) => new MediaStream([black(...args), silence()])\n//             window.localStream = blackSilence()\n//             localVideoRef.current.srcObject = window.localStream\n\n//             for (let id in connections) {\n//                 connections[id].addStream(window.localStream)\n\n//                 connections[id].createOffer().then((description) => {\n//                     connections[id].setLocalDescription(description)\n//                         .then(() => {\n//                             socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\n//                         })\n//                         .catch(e => console.log(e))\n//                 })\n//             }\n//             stream.gettracks().forEach(track => track.onended = () => {\n//                 setVideo(false)\n//                 setAudio(false);\n//                  try {\n//                 let tracks = localVideoRef.current.srcObject.getTracks()\n//                 tracks.forEach(track => track.stop())\n//             } catch (e) { console.log(e) }\n//             })\n//              for (let id in connections) {\n//                 connections[id].addStream(window.localStream)\n\n//                 connections[id].createOffer().then((description) => {\n//                     connections[id].setLocalDescription(description)\n//                         .then(() => {\n//                             socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\n//                         })\n//                         .catch(e => console.log(e))\n//                 })\n//             }\n//         })\n//     }\n\n//     let getUserMedia = () => {\n//         if((video && videoAvailable)|| (audio && audioAvailable)) {\n//             navigator.mediaDevices.getUserMedia({video: video, audio: audio})\n//             .then(getUserMediaSuccess)\n//             .then((stream) => { })\n//             .catch((e) => console.log(e))\n//         } else {\n//             try{\n//                 let  tracks = localVideoRef.current.srcObject.getTracks();\n//                 tracks.forEach(track => track.stop())\n//             } catch(e) {}\n//         }\n\n//     }\n\n//     let getDislayMediaSuccess = (stream) => {\n//         console.log(\"HERE\")\n//         try {\n//             window.localStream.getTracks().forEach(track => track.stop())\n//         } catch (e) { console.log(e) }\n\n//         window.localStream = stream\n//         localVideoRef.current.srcObject = stream\n\n//         for (let id in connections) {\n//             if (id === socketIdRef.current) continue\n\n//             connections[id].addStream(window.localStream)\n\n//             connections[id].createOffer().then((description) => {\n//                 connections[id].setLocalDescription(description)\n//                     .then(() => {\n//                         socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\n//                     })\n//                     .catch(e => console.log(e))\n//             })\n//         }\n\n//         stream.getTracks().forEach(track => track.onended = () => {\n//             setScreen(false)\n\n//             try {\n//                 let tracks = localVideoRef.current.srcObject.getTracks()\n//                 tracks.forEach(track => track.stop())\n//             } catch (e) { console.log(e) }\n\n//             let blackSilence = (...args) => new MediaStream([black(...args), silence()])\n//             window.localStream = blackSilence()\n//             localVideoRef.current.srcObject = window.localStream\n\n//             getUserMedia();\n\n//         })\n//     }\n\n//    useEffect(() => {\n//         if (video !== undefined && audio !== undefined) {\n//             getUserMedia();\n//             console.log(\"SET STATE HAS \", video, audio);\n\n//         }\n\n//     }, [video, audio])\n\n//     let addMessage = () => {\n//         setMessages((prevMessages) => [\n//             ...prevMessages,\n//             { sender: sender, data: data }\n//         ]);\n//         if (socketIdSender !== socketIdRef.current) {\n//             setNewMessages((prevNewMessages) => prevNewMessages + 1);\n//         }\n\n//     };\n\n//     let gotMessageFromServer = (fromId, message) => {\n//         var signal = JSON.parse(message)\n\n//         if (fromId !== socketIdRef.current) {\n//             if (signal.sdp) {\n//                 connections[fromId].setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(() => {\n//                     if (signal.sdp.type === 'offer') {\n//                         connections[fromId].createAnswer().then((description) => {\n//                             connections[fromId].setLocalDescription(description).then(() => {\n//                                 socketRef.current.emit('signal', fromId, JSON.stringify({ 'sdp': connections[fromId].localDescription }))\n//                             }).catch(e => console.log(e))\n//                         }).catch(e => console.log(e))\n//                     }\n//                 }).catch(e => console.log(e))\n//             }\n\n//             if (signal.ice) {\n//                 connections[fromId].addIceCandidate(new RTCIceCandidate(signal.ice)).catch(e => console.log(e))\n//             }\n//         }\n//     }\n\n//        let connectToSocketServer = () => {\n//         socketRef.current = io.connect(server_url, { secure: false })\n\n//         socketRef.current.on('signal', gotMessageFromServer)\n\n//         socketRef.current.on('connect', () => {\n//             socketRef.current.emit('join-call', window.location.href)\n//             socketIdRef.current = socketRef.current.id\n\n//             socketRef.current.on('chat-message', addMessage)\n\n//             socketRef.current.on('user-left', (id) => {\n//                 setVideos((videos) => videos.filter((video) => video.socketId !== id))\n//             })\n\n//             socketRef.current.on('user-joined', (id, clients) => {\n//                 clients.forEach((socketListId) => {\n\n//                     connections[socketListId] = new RTCPeerConnection(peerConfigConnections)\n//                     // Wait for their ice candidate       \n//                     connections[socketListId].onicecandidate = function (event) {\n//                         if (event.candidate != null) {\n//                             socketRef.current.emit('signal', socketListId, JSON.stringify({ 'ice': event.candidate }))\n//                         }\n//                     }\n\n//                     // Wait for their video stream\n//                     connections[socketListId].onaddstream = (event) => {\n//                         console.log(\"BEFORE:\", videoRef.current);\n//                         console.log(\"FINDING ID: \", socketListId);\n\n//                         let videoExists = videoRef.current.find(video => video.socketId === socketListId);\n\n//                         if (videoExists) {\n//                             console.log(\"FOUND EXISTING\");\n\n//                             // Update the stream of the existing video\n//                             setVideos(videos => {\n//                                 const updatedVideos = videos.map(video =>\n//                                     video.socketId === socketListId ? { ...video, stream: event.stream } : video\n//                                 );\n//                                 videoRef.current = updatedVideos;\n//                                 return updatedVideos;\n//                             });\n//                         } else {\n//                             // Create a new video\n//                             console.log(\"CREATING NEW\");\n//                             let newVideo = {\n//                                 socketId: socketListId,\n//                                 stream: event.stream,\n//                                 autoplay: true,\n//                                 playsinline: true\n//                             };\n\n//                             setVideos(videos => {\n//                                 const updatedVideos = [...videos, newVideo];\n//                                 videoRef.current = updatedVideos;\n//                                 return updatedVideos;\n//                             });\n//                         }\n//                     };\n\n//                     // Add the local video stream\n//                     if (window.localStream !== undefined && window.localStream !== null) {\n//                         connections[socketListId].addStream(window.localStream)\n//                     } else {\n//                         let blackSilence = (...args) => new MediaStream([black(...args), silence()])\n//                         window.localStream = blackSilence()\n//                         connections[socketListId].addStream(window.localStream)\n//                     }\n//                 })\n\n//                 if (id === socketIdRef.current) {\n//                     for (let id2 in connections) {\n//                         if (id2 === socketIdRef.current) continue\n\n//                         try {\n//                             connections[id2].addStream(window.localStream)\n//                         } catch (e) { }\n\n//                         connections[id2].createOffer().then((description) => {\n//                             connections[id2].setLocalDescription(description)\n//                                 .then(() => {\n//                                     socketRef.current.emit('signal', id2, JSON.stringify({ 'sdp': connections[id2].localDescription }))\n//                                 })\n//                                 .catch(e => console.log(e))\n//                         })\n//                     }\n//                 }\n//             })\n//         })\n//     }\n\n//     let getMedia = () => {\n//         setVideo(videoAvailable);\n//         setAudio(audioAvailable);\n//         connectToSocketServer();\n\n//     }\n\n//      const getPermissions = async () => {\n//         try {\n//             const videoPermission = await navigator.mediaDevices.getUserMedia({ video: true });\n//             if (videoPermission) {\n//                 setVideoAvailable(true);\n//                 console.log('Video permission granted');\n//             } else {\n//                 setVideoAvailable(false);\n//                 console.log('Video permission denied');\n//             }\n\n//             const audioPermission = await navigator.mediaDevices.getUserMedia({ audio: true });\n//             if (audioPermission) {\n//                 setAudioAvailable(true);\n//                 console.log('Audio permission granted');\n//             } else {\n//                 setAudioAvailable(false);\n//                 console.log('Audio permission denied');\n//             }\n\n//             if (navigator.mediaDevices.getDisplayMedia) {\n//                 setScreenAvailable(true);\n//             } else {\n//                 setScreenAvailable(false);\n//             }\n\n//             if (videoAvailable || audioAvailable) {\n//                 const userMediaStream = await navigator.mediaDevices.getUserMedia({ video: videoAvailable, audio: audioAvailable });\n//                 if (userMediaStream) {\n//                     window.localStream = userMediaStream;\n//                     if (localVideoRef.current) {\n//                         localVideoRef.current.srcObject = userMediaStream;\n//                     }\n//                 }\n//             }\n//         } catch (error) {\n//             console.log(error);\n//         }\n//     };\n\n//   let silence = () => {\n//         let ctx = new AudioContext()\n//         let oscillator = ctx.createOscillator()\n//         let dst = oscillator.connect(ctx.createMediaStreamDestination())\n//         oscillator.start()\n//         ctx.resume()\n//         return Object.assign(dst.stream.getAudioTracks()[0], { enabled: false })\n//     }\n//     let black = ({ width = 640, height = 480 } = {}) => {\n//         let canvas = Object.assign(document.createElement(\"canvas\"), { width, height })\n//         canvas.getContext('2d').fillRect(0, 0, width, height)\n//         let stream = canvas.captureStream()\n//         return Object.assign(stream.getVideoTracks()[0], { enabled: false })\n//     }\n\n//      let handleVideo = () => {\n//         setVideo(!video);\n//         // getUserMedia();\n//     }\n//     let handleAudio = () => {\n//         setAudio(!audio)\n//         // getUserMedia();\n//     }\n\n//     useEffect(() => {\n//         if (screen !== undefined) {\n//             getDislayMedia();\n//         }\n//     }, [screen])\n\n//     let handleScreen = () => {\n//         setScreen(!screen);\n//     }\n\n//      let sendMessage = () => {\n//         console.log(socketRef.current);\n//         socketRef.current.emit('chat-message', message, username)\n//         setMessage(\"\");\n\n//         // this.setState({ message: \"\", sender: username })\n//     }\n\n//    let connect = () => {\n//         setAskForUsername(false);\n//         getMedia();\n//     }\n\n//   return(\n//         <div>\n//            {askForUsername === true ?\n//             <div>\n//                 <h2>Enter into Lobby </h2>\n//                 <TextField id=\"outlined-basic\" label=\"Username\" value={username} onChange={e => setUsername(e.target.value)} variant=\"outlined\" />\n//                     <Button variant=\"contained\" onClick={connect}>Connect</Button>\n\n//                     <div>\n//                         <video ref= {localVideoRef} autoPlay muted> </video>\n//                          </div>\n\n//             </div>  :\n//              <div className = {styles.meetVideoContainer}>\n//                  {showModal ? <div className={styles.chatRoom}>\n\n//                         <div className={styles.chatContainer}>\n//                             <h1>Chat</h1>\n\n//                             <div className={styles.chattingDisplay}>\n\n//                                 {messages.length !== 0 ? messages.map((item, index) => {\n\n//                                     console.log(messages)\n//                                     return (\n//                                         <div style={{ marginBottom: \"20px\" }} key={index}>\n//                                             <p style={{ fontWeight: \"bold\" }}>{item.sender}</p>\n//                                             <p>{item.data}</p>\n//                                         </div>\n//                                     )\n//                                 }) : <p>No Messages Yet</p>}\n//                   </div>\n\n//                             <div className={styles.chattingArea}>\n//                                 <TextField value={message} onChange={(e) => setMessage(e.target.value)} id=\"outlined-basic\" label=\"Enter Your chat\" variant=\"outlined\" />\n//                                 <Button variant='contained' onClick={sendMessage}>Send</Button>\n//                             </div>\n\n//                         </div>\n//                     </div> : <></>}\n\n//                 <div className={styles.buttonContainers}>\n\n//                     <IconButton onClick={handleVideo} style={{ color: \"white\" }}>\n//                          {(video === true) ? <VideocamIcon /> : <VideocamOffIcon />}\n//                         </IconButton>\n//                         <IconButton style={{ color: \"red\" }}>\n//                             <CallEndIcon  />\n//                         </IconButton>\n//                           <IconButton onClick={handleAudio}  style={{ color: \"white\" }}>\n//                             {audio === true ? <MicIcon /> : <MicOffIcon />}\n//                         </IconButton>\n//                           {screenAvailable === true ?\n//                             <IconButton onClick={handleScreen} style={{ color: \"white\" }}>\n//                                 {screen === true ? <ScreenShareIcon /> : <StopScreenShareIcon />}\n//                             </IconButton> : <></>}\n//                             <Badge badgeContent={newMessages} max={999} color='orange'>\n//                             <IconButton  onClick={() => setModal(!showModal)} style={{ color: \"white\" }}>\n//                                 <ChatIcon />                        </IconButton>\n//                         </Badge>\n\n//                     </div>\n\n//             <video className = {styles.meetUserVideo} ref={localVideoRef} autoPlay muted> </video>\n//             <div classNaame={styles.conferenceView}>\n//             {videos.map((video) => (\n\n//                 <div className={styles.conferenceView} key={video.socketId}>\n//                {/* <h2>{video.socketId}</h2> */}\n//                <video data-socket={video.socketId}\n//                ref={ref => {\n//                 if(ref && video.stream) {\n//                     ref.srcObject = video.stream;\n//                 }\n//                }}\n//                autoPlay\n//                >\n\n//                </video>\n//                </div>\n\n//             ))}\n\n//             </div>\n//             </div>\n\n//             }\n//             </div>\n//             )\n//         }","map":{"version":3,"names":[],"sources":["C:/Users/hp/Desktop/VC/frontend/src/pages/VideoMeet.jsx"],"sourcesContent":["// import React, { useEffect, useRef, useState } from 'react'\r\n// import styles from \"../styles/videoComponent.module.css\";\r\n// import { io } from \"socket.io-client\";\r\n// import { Badge, IconButton, TextField } from '@mui/material';\r\n// import { Button } from '@mui/material';\r\n// import VideocamIcon from '@mui/icons-material/Videocam';\r\n// import VideocamOffIcon from '@mui/icons-material/VideocamOff'\r\n// import CallEndIcon from '@mui/icons-material/CallEnd'\r\n// import MicIcon from '@mui/icons-material/Mic'\r\n// import MicOffIcon from '@mui/icons-material/MicOff'\r\n// import ScreenShareIcon from '@mui/icons-material/ScreenShare';\r\n// import StopScreenShareIcon from '@mui/icons-material/StopScreenShare'\r\n// import ChatIcon from '@mui/icons-material/Chat'\r\n\r\n\r\n// const server_url = \"http://localhost:8000\";\r\n\r\n// var connections = {};\r\n\r\n// const peerConfigConnections = {\r\n//     \"iceServers\" : [\r\n//         { \"urls\" : \"stun:stun.l.google.com:19302\"}\r\n//     ]\r\n// }\r\n\r\n\r\n// export default function VideoMeetComponent() {\r\n\r\n//     var socketRef = useRef();\r\n\r\n//     let socketIdRef = useRef();\r\n\r\n//     let localVideoRef = useRef();\r\n\r\n//     let[videoAvailable, setVideoAvailable] = useState(true);\r\n\r\n//     let[audioAvailable, setAudioAvailable] = useState(true);\r\n\r\n//     let[video, setVideo] = useState([]);\r\n    \r\n//     let [audio, setAudio] = useState();\r\n\r\n//     let[screen, setScreen] = useState();\r\n\r\n//     let[showModal, setModal] = useState(true);\r\n\r\n//     let[screenAvailable, setScreenAvailable] = useState();\r\n\r\n//     let[messages, setMessages] = useState([])\r\n\r\n//     let[message, setMessage] = useState(\"\");\r\n\r\n//     let[newMessages, setNewMessages] = useState(0);\r\n\r\n//     let [askForUsername, setAskForUsername] = useState(true);\r\n\r\n//     let [username, setUsername] = useState(\"\");\r\n\r\n//     const videoRef = useRef([])\r\n\r\n//     let [videos, setVideos] = useState([])\r\n\r\n//     useEffect(() => {\r\n//         // console.log(\"HELLO\")\r\n//         getPermissions();\r\n//     },[])\r\n\r\n//     let getDislayMedia = () => {\r\n//         if (screen) {\r\n//             if (navigator.mediaDevices.getDisplayMedia) {\r\n//                 navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })\r\n//                     .then(getDislayMediaSuccess)\r\n//                     .then((stream) => { })\r\n//                     .catch((e) => console.log(e))\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//    let getUserMediaSuccess = (stream) => {\r\n//         try {\r\n//             window.localStream.getTracks().forEach(track => track.stop())\r\n//         } catch (e) { console.log(e) }\r\n\r\n//         window.localStream = stream\r\n//         localVideoRef.current.srcObject = stream\r\n\r\n//         for (let id in connections) {\r\n//             if (id === socketIdRef.current) continue\r\n\r\n//             connections[id].addStream(window.localStream)\r\n\r\n//             connections[id].createOffer().then((description) => {\r\n//                 console.log(description)\r\n//                 connections[id].setLocalDescription(description)\r\n//                     .then(() => {\r\n//                         socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\r\n//                     })\r\n//                     .catch(e => console.log(e))\r\n//             })\r\n//         }\r\n\r\n//         stream.getTracks().forEach(track => track.onended = () => {\r\n//             setVideo(false);\r\n//             setAudio(false);\r\n\r\n//             try {\r\n//                 let tracks = localVideoRef.current.srcObject.getTracks()\r\n//                 tracks.forEach(track => track.stop())\r\n//             } catch (e) { console.log(e) }\r\n\r\n//             let blackSilence = (...args) => new MediaStream([black(...args), silence()])\r\n//             window.localStream = blackSilence()\r\n//             localVideoRef.current.srcObject = window.localStream\r\n\r\n//             for (let id in connections) {\r\n//                 connections[id].addStream(window.localStream)\r\n\r\n//                 connections[id].createOffer().then((description) => {\r\n//                     connections[id].setLocalDescription(description)\r\n//                         .then(() => {\r\n//                             socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\r\n//                         })\r\n//                         .catch(e => console.log(e))\r\n//                 })\r\n//             }\r\n//             stream.gettracks().forEach(track => track.onended = () => {\r\n//                 setVideo(false)\r\n//                 setAudio(false);\r\n//                  try {\r\n//                 let tracks = localVideoRef.current.srcObject.getTracks()\r\n//                 tracks.forEach(track => track.stop())\r\n//             } catch (e) { console.log(e) }\r\n//             })\r\n//              for (let id in connections) {\r\n//                 connections[id].addStream(window.localStream)\r\n\r\n//                 connections[id].createOffer().then((description) => {\r\n//                     connections[id].setLocalDescription(description)\r\n//                         .then(() => {\r\n//                             socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\r\n//                         })\r\n//                         .catch(e => console.log(e))\r\n//                 })\r\n//             }\r\n//         })\r\n//     }\r\n\r\n//     let getUserMedia = () => {\r\n//         if((video && videoAvailable)|| (audio && audioAvailable)) {\r\n//             navigator.mediaDevices.getUserMedia({video: video, audio: audio})\r\n//             .then(getUserMediaSuccess)\r\n//             .then((stream) => { })\r\n//             .catch((e) => console.log(e))\r\n//         } else {\r\n//             try{\r\n//                 let  tracks = localVideoRef.current.srcObject.getTracks();\r\n//                 tracks.forEach(track => track.stop())\r\n//             } catch(e) {}\r\n//         }\r\n        \r\n//     }\r\n\r\n//     let getDislayMediaSuccess = (stream) => {\r\n//         console.log(\"HERE\")\r\n//         try {\r\n//             window.localStream.getTracks().forEach(track => track.stop())\r\n//         } catch (e) { console.log(e) }\r\n\r\n//         window.localStream = stream\r\n//         localVideoRef.current.srcObject = stream\r\n\r\n//         for (let id in connections) {\r\n//             if (id === socketIdRef.current) continue\r\n\r\n//             connections[id].addStream(window.localStream)\r\n\r\n//             connections[id].createOffer().then((description) => {\r\n//                 connections[id].setLocalDescription(description)\r\n//                     .then(() => {\r\n//                         socketRef.current.emit('signal', id, JSON.stringify({ 'sdp': connections[id].localDescription }))\r\n//                     })\r\n//                     .catch(e => console.log(e))\r\n//             })\r\n//         }\r\n\r\n//         stream.getTracks().forEach(track => track.onended = () => {\r\n//             setScreen(false)\r\n\r\n//             try {\r\n//                 let tracks = localVideoRef.current.srcObject.getTracks()\r\n//                 tracks.forEach(track => track.stop())\r\n//             } catch (e) { console.log(e) }\r\n\r\n//             let blackSilence = (...args) => new MediaStream([black(...args), silence()])\r\n//             window.localStream = blackSilence()\r\n//             localVideoRef.current.srcObject = window.localStream\r\n\r\n//             getUserMedia();\r\n\r\n//         })\r\n//     }\r\n\r\n//    useEffect(() => {\r\n//         if (video !== undefined && audio !== undefined) {\r\n//             getUserMedia();\r\n//             console.log(\"SET STATE HAS \", video, audio);\r\n\r\n//         }\r\n\r\n\r\n//     }, [video, audio])\r\n\r\n//     let addMessage = () => {\r\n//         setMessages((prevMessages) => [\r\n//             ...prevMessages,\r\n//             { sender: sender, data: data }\r\n//         ]);\r\n//         if (socketIdSender !== socketIdRef.current) {\r\n//             setNewMessages((prevNewMessages) => prevNewMessages + 1);\r\n//         }\r\n         \r\n//     };\r\n\r\n//     let gotMessageFromServer = (fromId, message) => {\r\n//         var signal = JSON.parse(message)\r\n\r\n//         if (fromId !== socketIdRef.current) {\r\n//             if (signal.sdp) {\r\n//                 connections[fromId].setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(() => {\r\n//                     if (signal.sdp.type === 'offer') {\r\n//                         connections[fromId].createAnswer().then((description) => {\r\n//                             connections[fromId].setLocalDescription(description).then(() => {\r\n//                                 socketRef.current.emit('signal', fromId, JSON.stringify({ 'sdp': connections[fromId].localDescription }))\r\n//                             }).catch(e => console.log(e))\r\n//                         }).catch(e => console.log(e))\r\n//                     }\r\n//                 }).catch(e => console.log(e))\r\n//             }\r\n\r\n//             if (signal.ice) {\r\n//                 connections[fromId].addIceCandidate(new RTCIceCandidate(signal.ice)).catch(e => console.log(e))\r\n//             }\r\n//         }\r\n//     }\r\n  \r\n\r\n//        let connectToSocketServer = () => {\r\n//         socketRef.current = io.connect(server_url, { secure: false })\r\n\r\n//         socketRef.current.on('signal', gotMessageFromServer)\r\n\r\n//         socketRef.current.on('connect', () => {\r\n//             socketRef.current.emit('join-call', window.location.href)\r\n//             socketIdRef.current = socketRef.current.id\r\n\r\n//             socketRef.current.on('chat-message', addMessage)\r\n\r\n//             socketRef.current.on('user-left', (id) => {\r\n//                 setVideos((videos) => videos.filter((video) => video.socketId !== id))\r\n//             })\r\n\r\n//             socketRef.current.on('user-joined', (id, clients) => {\r\n//                 clients.forEach((socketListId) => {\r\n\r\n//                     connections[socketListId] = new RTCPeerConnection(peerConfigConnections)\r\n//                     // Wait for their ice candidate       \r\n//                     connections[socketListId].onicecandidate = function (event) {\r\n//                         if (event.candidate != null) {\r\n//                             socketRef.current.emit('signal', socketListId, JSON.stringify({ 'ice': event.candidate }))\r\n//                         }\r\n//                     }\r\n\r\n//                     // Wait for their video stream\r\n//                     connections[socketListId].onaddstream = (event) => {\r\n//                         console.log(\"BEFORE:\", videoRef.current);\r\n//                         console.log(\"FINDING ID: \", socketListId);\r\n\r\n//                         let videoExists = videoRef.current.find(video => video.socketId === socketListId);\r\n\r\n//                         if (videoExists) {\r\n//                             console.log(\"FOUND EXISTING\");\r\n\r\n//                             // Update the stream of the existing video\r\n//                             setVideos(videos => {\r\n//                                 const updatedVideos = videos.map(video =>\r\n//                                     video.socketId === socketListId ? { ...video, stream: event.stream } : video\r\n//                                 );\r\n//                                 videoRef.current = updatedVideos;\r\n//                                 return updatedVideos;\r\n//                             });\r\n//                         } else {\r\n//                             // Create a new video\r\n//                             console.log(\"CREATING NEW\");\r\n//                             let newVideo = {\r\n//                                 socketId: socketListId,\r\n//                                 stream: event.stream,\r\n//                                 autoplay: true,\r\n//                                 playsinline: true\r\n//                             };\r\n\r\n//                             setVideos(videos => {\r\n//                                 const updatedVideos = [...videos, newVideo];\r\n//                                 videoRef.current = updatedVideos;\r\n//                                 return updatedVideos;\r\n//                             });\r\n//                         }\r\n//                     };\r\n\r\n\r\n//                     // Add the local video stream\r\n//                     if (window.localStream !== undefined && window.localStream !== null) {\r\n//                         connections[socketListId].addStream(window.localStream)\r\n//                     } else {\r\n//                         let blackSilence = (...args) => new MediaStream([black(...args), silence()])\r\n//                         window.localStream = blackSilence()\r\n//                         connections[socketListId].addStream(window.localStream)\r\n//                     }\r\n//                 })\r\n\r\n//                 if (id === socketIdRef.current) {\r\n//                     for (let id2 in connections) {\r\n//                         if (id2 === socketIdRef.current) continue\r\n\r\n//                         try {\r\n//                             connections[id2].addStream(window.localStream)\r\n//                         } catch (e) { }\r\n\r\n//                         connections[id2].createOffer().then((description) => {\r\n//                             connections[id2].setLocalDescription(description)\r\n//                                 .then(() => {\r\n//                                     socketRef.current.emit('signal', id2, JSON.stringify({ 'sdp': connections[id2].localDescription }))\r\n//                                 })\r\n//                                 .catch(e => console.log(e))\r\n//                         })\r\n//                     }\r\n//                 }\r\n//             })\r\n//         })\r\n//     }\r\n\r\n//     let getMedia = () => {\r\n//         setVideo(videoAvailable);\r\n//         setAudio(audioAvailable);\r\n//         connectToSocketServer();\r\n\r\n//     }\r\n\r\n\r\n//      const getPermissions = async () => {\r\n//         try {\r\n//             const videoPermission = await navigator.mediaDevices.getUserMedia({ video: true });\r\n//             if (videoPermission) {\r\n//                 setVideoAvailable(true);\r\n//                 console.log('Video permission granted');\r\n//             } else {\r\n//                 setVideoAvailable(false);\r\n//                 console.log('Video permission denied');\r\n//             }\r\n\r\n//             const audioPermission = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n//             if (audioPermission) {\r\n//                 setAudioAvailable(true);\r\n//                 console.log('Audio permission granted');\r\n//             } else {\r\n//                 setAudioAvailable(false);\r\n//                 console.log('Audio permission denied');\r\n//             }\r\n\r\n//             if (navigator.mediaDevices.getDisplayMedia) {\r\n//                 setScreenAvailable(true);\r\n//             } else {\r\n//                 setScreenAvailable(false);\r\n//             }\r\n\r\n//             if (videoAvailable || audioAvailable) {\r\n//                 const userMediaStream = await navigator.mediaDevices.getUserMedia({ video: videoAvailable, audio: audioAvailable });\r\n//                 if (userMediaStream) {\r\n//                     window.localStream = userMediaStream;\r\n//                     if (localVideoRef.current) {\r\n//                         localVideoRef.current.srcObject = userMediaStream;\r\n//                     }\r\n//                 }\r\n//             }\r\n//         } catch (error) {\r\n//             console.log(error);\r\n//         }\r\n//     };\r\n\r\n//   let silence = () => {\r\n//         let ctx = new AudioContext()\r\n//         let oscillator = ctx.createOscillator()\r\n//         let dst = oscillator.connect(ctx.createMediaStreamDestination())\r\n//         oscillator.start()\r\n//         ctx.resume()\r\n//         return Object.assign(dst.stream.getAudioTracks()[0], { enabled: false })\r\n//     }\r\n//     let black = ({ width = 640, height = 480 } = {}) => {\r\n//         let canvas = Object.assign(document.createElement(\"canvas\"), { width, height })\r\n//         canvas.getContext('2d').fillRect(0, 0, width, height)\r\n//         let stream = canvas.captureStream()\r\n//         return Object.assign(stream.getVideoTracks()[0], { enabled: false })\r\n//     }\r\n\r\n//      let handleVideo = () => {\r\n//         setVideo(!video);\r\n//         // getUserMedia();\r\n//     }\r\n//     let handleAudio = () => {\r\n//         setAudio(!audio)\r\n//         // getUserMedia();\r\n//     }\r\n\r\n//     useEffect(() => {\r\n//         if (screen !== undefined) {\r\n//             getDislayMedia();\r\n//         }\r\n//     }, [screen])\r\n\r\n//     let handleScreen = () => {\r\n//         setScreen(!screen);\r\n//     }\r\n\r\n\r\n\r\n//      let sendMessage = () => {\r\n//         console.log(socketRef.current);\r\n//         socketRef.current.emit('chat-message', message, username)\r\n//         setMessage(\"\");\r\n\r\n//         // this.setState({ message: \"\", sender: username })\r\n//     }\r\n    \r\n//    let connect = () => {\r\n//         setAskForUsername(false);\r\n//         getMedia();\r\n//     }\r\n   \r\n//   return(\r\n//         <div>\r\n//            {askForUsername === true ?\r\n//             <div>\r\n//                 <h2>Enter into Lobby </h2>\r\n//                 <TextField id=\"outlined-basic\" label=\"Username\" value={username} onChange={e => setUsername(e.target.value)} variant=\"outlined\" />\r\n//                     <Button variant=\"contained\" onClick={connect}>Connect</Button>\r\n\r\n//                     <div>\r\n//                         <video ref= {localVideoRef} autoPlay muted> </video>\r\n//                          </div>\r\n\r\n//             </div>  :\r\n//              <div className = {styles.meetVideoContainer}>\r\n//                  {showModal ? <div className={styles.chatRoom}>\r\n\r\n//                         <div className={styles.chatContainer}>\r\n//                             <h1>Chat</h1>\r\n\r\n//                             <div className={styles.chattingDisplay}>\r\n\r\n//                                 {messages.length !== 0 ? messages.map((item, index) => {\r\n\r\n//                                     console.log(messages)\r\n//                                     return (\r\n//                                         <div style={{ marginBottom: \"20px\" }} key={index}>\r\n//                                             <p style={{ fontWeight: \"bold\" }}>{item.sender}</p>\r\n//                                             <p>{item.data}</p>\r\n//                                         </div>\r\n//                                     )\r\n//                                 }) : <p>No Messages Yet</p>}\r\n//                   </div>\r\n\r\n//                             <div className={styles.chattingArea}>\r\n//                                 <TextField value={message} onChange={(e) => setMessage(e.target.value)} id=\"outlined-basic\" label=\"Enter Your chat\" variant=\"outlined\" />\r\n//                                 <Button variant='contained' onClick={sendMessage}>Send</Button>\r\n//                             </div>\r\n\r\n\r\n//                         </div>\r\n//                     </div> : <></>}\r\n\r\n//                 <div className={styles.buttonContainers}>\r\n                       \r\n//                     <IconButton onClick={handleVideo} style={{ color: \"white\" }}>\r\n//                          {(video === true) ? <VideocamIcon /> : <VideocamOffIcon />}\r\n//                         </IconButton>\r\n//                         <IconButton style={{ color: \"red\" }}>\r\n//                             <CallEndIcon  />\r\n//                         </IconButton>\r\n//                           <IconButton onClick={handleAudio}  style={{ color: \"white\" }}>\r\n//                             {audio === true ? <MicIcon /> : <MicOffIcon />}\r\n//                         </IconButton>\r\n//                           {screenAvailable === true ?\r\n//                             <IconButton onClick={handleScreen} style={{ color: \"white\" }}>\r\n//                                 {screen === true ? <ScreenShareIcon /> : <StopScreenShareIcon />}\r\n//                             </IconButton> : <></>}\r\n//                             <Badge badgeContent={newMessages} max={999} color='orange'>\r\n//                             <IconButton  onClick={() => setModal(!showModal)} style={{ color: \"white\" }}>\r\n//                                 <ChatIcon />                        </IconButton>\r\n//                         </Badge>\r\n\r\n\r\n//                     </div>\r\n\r\n//             <video className = {styles.meetUserVideo} ref={localVideoRef} autoPlay muted> </video>\r\n//             <div classNaame={styles.conferenceView}>\r\n//             {videos.map((video) => (\r\n\r\n//                 <div className={styles.conferenceView} key={video.socketId}>\r\n//                {/* <h2>{video.socketId}</h2> */}\r\n//                <video data-socket={video.socketId}\r\n//                ref={ref => {\r\n//                 if(ref && video.stream) {\r\n//                     ref.srcObject = video.stream;\r\n//                 }\r\n//                }}\r\n//                autoPlay\r\n//                >\r\n\r\n//                </video>\r\n//                </div>\r\n\r\n\r\n//             ))}\r\n\r\n//             </div>\r\n//             </div>\r\n\r\n                \r\n    \r\n//             }\r\n//             </div>\r\n//             )\r\n//         }\r\n        \r\n        \r\n    \r\n    \r\n    \r\n    \r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;;AAEA;AACA;;AAIA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}